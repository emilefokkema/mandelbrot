<html>
<head>
	<style>
		body{margin: 0; padding: 0}
		canvas{width: 100%;height:100%;}
	</style>
	<script type="text/javascript" src="parallel-processor.js"></script>
</head>
<body>
<canvas width="900" height="700" id="canvas"/>
<script type="application/javascript">
	(function(){
		var canvas = document.getElementById("canvas");
		var clientRect = canvas.getBoundingClientRect();
		var width = clientRect.width * devicePixelRatio;
		var height = clientRect.height * devicePixelRatio;
		canvas.setAttribute("width", width);
		canvas.setAttribute("height", height);
		var context = canvas.getContext("2d");
		var processor = new ParallelProcessor(navigator.hardwareConcurrency, "("+(function(){
			var size, pixelSize, numberOfPixels, scaleX, scaleY, maxIterations;
			var escapeStep = function(x, y){
				var zrn, zin, zr = 0, zi = 0, cr = x, ci = y, step = 0, modsq = 0;
				while(modsq < 8 && step++ < maxIterations){
					zrn = zr * zr - zi * zi + cr;
					zin = 2 * zr * zi + ci;
					zr = zrn;
					zi = zin;
					modsq = zr * zr + zi * zi;
				}
				return {modsq:modsq, step:step};
			};
			var mod2 = function(h1){
				while(h1 >= 2){
					h1 -= 2;
				}
				return h1;
			};
			var hslToRgba = function(h, s, l){
				while(h > 2 * Math.PI){
					h -= 2 * Math.PI;
				}
				var chroma = s * (1 - Math.abs(2 * l - 1));
				var h1 = 3 * h / Math.PI;
				var x = chroma * (1 - Math.abs(mod2(h1) - 1));
				var r1, g1, b1;
				if(h1 < 1){
					r1 = chroma;
					g1 = x;
					b1 = 0;
				}else if(h1 < 2){
					r1 = x;
					g1 = chroma;
					b1 = 0;
				}else if(h1 < 3){
					r1 = 0;
					g1 = chroma;
					b1 = x;
				}else if(h1 < 4){
					r1 = 0;
					g1 = x;
					b1 = chroma;
				}else if(h1 < 5){
					r1 = x;
					g1 = 0;
					b1 = chroma;
				}else{
					r1 = chroma;
					g1 = 0;
					b1 = x;
				}
				var m = l - chroma / 2;
				var r = (r1 + m) * 255;
				var g = (g1 + m) * 255;
				var b = (b1 + m) * 255;
				return {r: r, g: g, b: b, a: 255};
			};

			var log2 = Math.log(2);
			var getRgba = function(x, y){
				var st = escapeStep(x, y);
				var normalizedStep = st.step + 1 - Math.log(Math.log(st.modsq) / (2 * log2)) / log2;
				var hue = Math.PI * normalizedStep / 90;
				var lightness = st.modsq < 4 ? 0 : 0.5 * (1 + Math.sin(normalizedStep / 20));
				return hslToRgba(hue, 0.5, lightness);
			};
			var drawPixelWithColor = function(array, x, y, rgba){
				var left = x * pixelSize;
				var top = y * size * pixelSize;
				for(var yy = 0; yy < pixelSize; yy++){
					for(var xx=0; xx < pixelSize; xx++){
						var index = (top + yy * size + left + xx) * 4;
						array[index] = rgba.r;
						array[index + 1] = rgba.g;
						array[index + 2] = rgba.b;
						array[index + 3] = rgba.a;
					}
				}
			};
			process = function(req){
				var origX = req.origX, origY = req.origY;
				var array = new Uint8ClampedArray(4 * size * size);
				for(var tileY = 0;tileY < numberOfPixels; tileY+=1){
					for(var tileX = 0; tileX < numberOfPixels; tileX+=1){
						var realX = origX + (tileX + 0.5) * pixelSize * scaleX;
						var realY = origY + (tileY + 0.5) * pixelSize * scaleY;
						var rgba = getRgba(realX, realY);
						drawPixelWithColor(array, tileX, tileY, rgba);
					}
				}
				return array.buffer;
			};

			update = function(_size, _pixelSize, _scaleX, _scaleY, _maxIterations){
				size = _size;
				pixelSize = _pixelSize;
				numberOfPixels = size / pixelSize;
				scaleX = _scaleX;
				scaleY = _scaleY;
				maxIterations = _maxIterations;
			};
		}).toString()+")()");
		var currentCancellationToken = processor.getCancellationToken();
		var centerX = 0;
		var centerY = 0;
		var virtualWidth = 4;
		var drawTile = async function(x, y, origX, origY, size, cancellationToken){
			var buffer = await processor.process({origX: origX, origY: origY}, cancellationToken);
			var array = new Uint8ClampedArray(buffer);
			var imageData = new ImageData(array, size);
			context.putImageData(imageData, x, y);
		};
		var drawWithPixelSizeAndMaxIterations = async function(size, pixelSize, maxIterations, cancellationToken){
			var scale = virtualWidth / width;
			await processor.update(size, pixelSize, scale, -scale, maxIterations);
			var nRows = Math.floor(height / size) + 1;
			var nCols = Math.floor(width / size) + 1;
			var virtualHeight = height * scale;
			var left = centerX - virtualWidth / 2;
			var top = centerY + virtualHeight / 2;
			var virtualTileSize = size * scale;
			var promises = [];
			var indices = [];
			for(var i=0;i<nRows;i++){
				for(var j=0;j<nCols;j++){
					indices.push({i:i, j:j})
				}
			}
			while(indices.length > 0){
				var ij = indices.splice(Math.floor(Math.random() * indices.length), 1)[0];
				var i = ij.i;
				var j = ij.j;
				promises.push(drawTile(j * size, i * size, left + j * virtualTileSize, top - i * virtualTileSize, size, cancellationToken));

			}
			await Promise.all(promises);
		}
		var draw = async function(){
			var cancellationToken = currentCancellationToken;
			await drawWithPixelSizeAndMaxIterations(600, 75, 4000, cancellationToken);
			if(cancellationToken.cancelled){
				return;
			}
			await drawWithPixelSizeAndMaxIterations(300, 1, 4000, cancellationToken);
			if(cancellationToken.cancelled){
				return;
			}
			await drawWithPixelSizeAndMaxIterations(300, 1, 10000, cancellationToken);
		};
		var zoomIn = function(clientX, clientY){
			var scale = virtualWidth / width;
			var virtualHeight = height * scale;
			var virtualX = (centerX - virtualWidth / 2) + clientX * scale;
			var virtualY = (centerY + virtualHeight / 2) - clientY * scale;
			centerX = virtualX;
			centerY = virtualY;
			virtualWidth = virtualWidth / 3;
			draw();
		};
		var zoomOut = function(){
			virtualWidth = virtualWidth * 3;
			draw();
		};
		draw();
		var borderWidth = Math.min(width / 6, height / 6);
		canvas.addEventListener("click", function(ev){
			console.log("click")
			currentCancellationToken.cancel();
			currentCancellationToken = processor.getCancellationToken();
			var clientX = ev.clientX * devicePixelRatio;
			var clientY = ev.clientY * devicePixelRatio;
			if(clientX < borderWidth || width - clientX < borderWidth || clientY < borderWidth || height - clientY < borderWidth){
				zoomOut();
			}else{
				zoomIn(clientX, clientY);
			}
		});
	})();
</script>
</body>
</html>