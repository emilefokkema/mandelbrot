<html>
<head>
	<style>
		body{margin: 0; padding: 0}
		canvas{width: 100%;height:100%;}
	</style>
	<script type="text/javascript" src="parallel-processor.js"></script>
</head>
<body>
<canvas width="900" height="700" id="canvas"/>
<script type="application/javascript">
	(function(){
		var canvas = document.getElementById("canvas");
		var clientRect = canvas.getBoundingClientRect();
		var width = clientRect.width * devicePixelRatio;
		var height = clientRect.height * devicePixelRatio;
		canvas.setAttribute("width", width);
		canvas.setAttribute("height", height);
		var context = canvas.getContext("2d");
		var processor = new ParallelProcessor(navigator.hardwareConcurrency, window.location.origin + window.location.pathname.replace(/[^/]*$/,"mandelbrot-processor.js"));
		var currentCancellationToken = processor.getCancellationToken();
		var centerX = 0;
		var centerY = 0;
		var virtualWidth = 4;
		var latestClickDate = undefined;
		var drawTile = async function(x, y, origX, origY, size, cancellationToken){
			var buffer = await processor.process({origX: origX, origY: origY}, cancellationToken);
			var array = new Uint8ClampedArray(buffer);
			var imageData = new ImageData(array, size);
			if(latestClickDate !== undefined){
				var diff = +new Date() - latestClickDate;
				latestClickDate = undefined;
				console.log("drawing after "+diff+" ms");
			}
			context.putImageData(imageData, x, y);
		};
		var drawWithPixelSizeAndMaxIterations = async function(size, pixelSize, maxIterations, cancellationToken){
			var scale = virtualWidth / width;
			await processor.update(size, pixelSize, scale, -scale, maxIterations);
			var nRows = Math.floor(height / size) + 1;
			var nCols = Math.floor(width / size) + 1;
			var virtualHeight = height * scale;
			var left = centerX - virtualWidth / 2;
			var top = centerY + virtualHeight / 2;
			var virtualTileSize = size * scale;
			var promises = [];
			var indices = [];
			for(var i=0;i<nRows;i++){
				for(var j=0;j<nCols;j++){
					indices.push({i:i, j:j})
				}
			}
			while(indices.length > 0){
				var ij = indices.splice(Math.floor(Math.random() * indices.length), 1)[0];
				var i = ij.i;
				var j = ij.j;
				promises.push(drawTile(j * size, i * size, left + j * virtualTileSize, top - i * virtualTileSize, size, cancellationToken));

			}
			await Promise.all(promises);
		}
		var draw = async function(){
			var cancellationToken = currentCancellationToken;
			await drawWithPixelSizeAndMaxIterations(600, 75, 4000, cancellationToken);
			if(cancellationToken.cancelled){
				return;
			}
			await drawWithPixelSizeAndMaxIterations(300, 1, 4000, cancellationToken);
			if(cancellationToken.cancelled){
				return;
			}
			await drawWithPixelSizeAndMaxIterations(300, 1, 10000, cancellationToken);
		};
		var zoomIn = function(clientX, clientY){
			var scale = virtualWidth / width;
			var virtualHeight = height * scale;
			var virtualX = (centerX - virtualWidth / 2) + clientX * scale;
			var virtualY = (centerY + virtualHeight / 2) - clientY * scale;
			centerX = virtualX;
			centerY = virtualY;
			virtualWidth = virtualWidth / 3;
			draw();
		};
		var zoomOut = function(){
			virtualWidth = virtualWidth * 3;
			draw();
		};
		draw();
		
		var borderWidth = Math.min(width / 6, height / 6);
		canvas.addEventListener("click", function(ev){
			console.log("click");
			latestClickDate = +new Date();
			currentCancellationToken.cancel();
			currentCancellationToken = processor.getCancellationToken();
			var clientX = ev.clientX * devicePixelRatio;
			var clientY = ev.clientY * devicePixelRatio;
			if(clientX < borderWidth || width - clientX < borderWidth || clientY < borderWidth || height - clientY < borderWidth){
				zoomOut();
			}else{
				zoomIn(clientX, clientY);
			}
		});
	})();
</script>
</body>
</html>