<html>
	<head>
		<script type="text/javascript" src="parallel-processor.js"></script>
		<script type="text/javascript" src="cobweb-images.js"></script>
		<style type="text/css">
			body{padding:0px;margin:0px;overflow: hidden;}
			#container{height:100%;}
			#left{display: inline-block;height:100%;}
			#right{display: inline-block;height:100%;}
			#valueMarker{position:absolute;bottom:0px;width:1px;background-color: #f00;}
			#controls{position:absolute;right:20px;bottom:20px;padding:20px;background-color: #fff;border: 1pt solid #000;}
			.control{user-select: none;cursor:pointer;display: inline-block;margin:3px;background-color: #aaa;}
			#cobwebProgress{position:absolute;left:10px;top:10px;}
			.progress{width:100px;height:10px;border:1pt solid #000;}
			.progress .done{width:0%;height:100%;background-color: #000;}
			#value{font-family: monospace;font-size: 15px;}
		</style>
	</head>
<body>

	<div id="container">
		<div id="left">
			<canvas id="cobweb"></canvas>
			<div id="cobwebProgress" class="progress">
				<div class="done" id="cobwebProgressDone"></div>
			</div>
		</div>
		<div id="right">
			<canvas id="bifurcationDiagram"></canvas>
			<div id="valueMarker"></div>
			<div id="controls">
				<div id="decrease" class="control">decrease</div>
				<div id="increase" class="control">increase</div>
				<div id="goleft" class="control">left</div>
				<div id="goright" class="control">right</div>
				<div id="zoomin" class="control">zoom in</div>
				<div id="zoomout" class="control">zoom out</div>
				<div id="play" class="control">play</div>
				<div id="stop" class="control">stop</div>
				<div id="value">r = 0.5</div>
			</div>
		</div>
	</div>
	
	
	<script>
		(function(){
			var createPathToScript = function(scriptName){
				return window.location.origin + window.location.pathname.replace(/[^/]*$/,scriptName);
			};

			class WorkerMessageHandler{
				constructor(){
					this.onceListeners = [];
					this.continuousListeners = [];
				}
				removeOnceListener(listener){
					var index = this.onceListeners.indexOf(listener);
					if(index > -1){
						this.onceListeners.splice(index, 1);
					}
				}
				removeContinuousListener(listener){
					var index = this.continuousListeners.findIndex(function(l){return l.handle === listener});
					if(index > -1){
						this.continuousListeners.splice(index);
					}
				}
				addContinuousListener(matchFn, listener){
					this.continuousListeners.push({
						matches: matchFn,
						handle: listener
					});
				}
				listenOnce(matchFn){
					var resolve;
					var promise = new Promise(function(res){resolve = res;});
					this.onceListeners.push({
						matches: matchFn,
						handle: resolve
					});
					return promise;
				}
				handleMessage(e){
					var data = e.data;
					var onceListeners = this.onceListeners.slice();
					for(var i=0;i<onceListeners.length;i++){
						var onceListener = onceListeners[i];
						if(!onceListener.matches(data)){
							continue;
						}
						this.removeOnceListener(onceListener);
						onceListener.handle(data);
					}
					for(var i=0;i<this.continuousListeners.length;i++){
						var continuousListener = this.continuousListeners[i];
						if(!continuousListener.matches(data)){
							continue;
						}
						continuousListener.handle(data);
					}
				}
			}
			var bufferCounter = 0;
			class OtherBuffer{
				constructor(){
					var self = this;
					this.worker = new Worker(createPathToScript("cobweb-image-buffer-worker.js"));
					var messageHandler = new WorkerMessageHandler();
					this.worker.onmessage = function(e){messageHandler.handleMessage(e);};
					this.messageHandler = messageHandler;
					this._loadingPromise = undefined;
					this.loading = false;
					this.onProgressHandlers = [];
					this.playing = false;
					this.id = bufferCounter++;
					this.loaded = false;
				}
				async playInTime(canvas, nrOfMilliseconds, onDisplayValue){
					var offscreenCanvas = canvas.transferControlToOffscreen();
					this.playing = true;
					var playingPromise = this.messageHandler.listenOnce(function(data){return data.donePlaying;});
					this.worker.postMessage({
						play: {
							canvas: offscreenCanvas,
							nrOfMilliseconds: nrOfMilliseconds
						}
					}, [offscreenCanvas]);
					await playingPromise;
					this.playing = false;
				}
				async discard(){
					var discardingPromise = this.messageHandler.listenOnce(function(data){return data.discarded;});
					this.worker.postMessage({discard: true});
					await discardingPromise;
					this.worker.terminate();
				}
				onProgress(ratio){
					for(var i=0;i<this.onProgressHandlers.length;i++){
						this.onProgressHandlers[i](ratio);
					}
				}
				async removeProgressHandler(handler){
					var index = this.onProgressHandlers.indexOf(handler);
					if(index === -1){
						return;
					}
					this.onProgressHandlers.splice(index, 1);
					if(this.onProgressHandlers.length === 0){
						var stopSendingPromise = this.messageHandler.listenOnce(function(data){return data.stoppedSendingProgressUpdate;});
						this.worker.postMessage({stopSendingProgressUpdate: true});
						await stopSendingPromise;
					}
				}
				async addProgressHandler(handler){
					var updateSendingPromise = this.messageHandler.listenOnce(function(data){return data.startedSendingProgressUpdate;});
					this.onProgressHandlers.push(handler);
					this.worker.postMessage({sendProgressUpdate: true});
					var ratio = await updateSendingPromise;
					if(this.loading){
						this.onProgress(ratio);
					}
				}
				startLoading(values, imageHeight){
					if(this.loading){
						return;
					}
					this.loading = true;
					console.log("buffer "+this.id+" starts loading with first value "+values[0]+" and last value "+values[values.length - 1]);
					var self = this;
					this._loadingPromise = this.createLoadingPromise(values, imageHeight).then(function(){self._loadingPromise = undefined;});
				}
				async createLoadingPromise(values, imageHeight){
					var self = this;
					var loaded = this.messageHandler.listenOnce(function(data){return data.loaded;});
					this.onProgress(0);
					var listener = function(data){self.onProgress(data.progress.ratio);};
					this.messageHandler.addContinuousListener(function(data){return data.progress;}, listener);
					this.worker.postMessage({
						instruction: {
							values: values,
							imageHeight: imageHeight
						}
					});
					await loaded;
					this.messageHandler.removeContinuousListener(listener);
					this.onProgress(1);
					this.loading = false;
					this.loaded = true;
				}
				async load(){
					if(this.loaded){
						return;
					}
					if(!this._loadingPromise){
						throw new Error("Cannot wait for loading to be ready, because buffer isn't loading")
					}
					await this._loadingPromise;
				}
			}
			class CobwebImageBuffer extends CobwebImageSet{
				constructor(processor, startValue, valueStep, length){
					super(processor, Array.apply(null, new Array(length)).map(function(x, i){return startValue + i * valueStep;}));
				}
				get lastValue(){
					return this.images[this.images.length - 1].value;
				}
				discard(){
					for(var i=0;i<this.images.length;i++){
						this.images[i].discard();
					}
				}

				async playInTime(context, nrOfMilliseconds, onDisplayValue){
					var currentTime = +new Date();
					var endTime = currentTime + nrOfMilliseconds;
					while(currentTime < endTime){
						var ratio = 1 - (endTime - currentTime) / nrOfMilliseconds;
						var imageIndex = Math.floor(this.images.length * ratio);
						this.images[imageIndex].draw(context);
						onDisplayValue && onDisplayValue(this.images[imageIndex].value);
						await new Promise(function(res){requestAnimationFrame(res);});
						currentTime = +new Date();
					}
				}

			}
			class ScaleWithValue{
				constructor(numberOfSteps){
					this._stepIndex = undefined;
					this.scaleStart = undefined;
					this.scaleEnd = undefined;
					this.numberOfSteps = numberOfSteps;
					this.steps = [];
				}
				get value(){
					return this.steps ? this.steps[this._stepIndex] : undefined;
				}
				setScale(start, end){
					this.scaleStart = start;
					this.scaleEnd = end;
					this.createSteps();
				}
				advanceStep(){
					this._stepIndex = Math.min(this.steps.length - 1, this._stepIndex + 1);
				}
				retreatStep(){
					this._stepIndex = Math.max(0, this._stepIndex - 1);
				}
				zoom(scale){
					var newSteps = this.steps.slice();
					var currentValue = this.steps[this._stepIndex];
					for(var i=0;i<newSteps.length;i++){
						if(i !== this._stepIndex){
							newSteps[i] = currentValue + (newSteps[i] - currentValue) * scale;
						}
					}
					this.steps = newSteps;
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.steps[this.steps.length - 1];
				}
				goToValueClosestToRatio(ratio){
					this._stepIndex = Math.floor((this.steps.length - 1) * ratio);
				}
				moveScaleRight(){
					var stepSize = this.getStepSize();
					this.steps.splice(0, 1);
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.scaleEnd + stepSize;
					this.steps.push(this.scaleEnd);
				}
				moveScaleLeft(){
					var stepSize = this.getStepSize();
					this.steps.splice(this.steps.length - 1, 1);
					this.scaleEnd = this.steps[this.steps.length - 1];
					this.scaleStart -= stepSize;
					this.steps.unshift(this.scaleStart);
				}
				getStepSize(){
					return (this.scaleEnd - this.scaleStart) / (this.numberOfSteps);
				}
				createSteps(){
					this.steps = [];
					var stepSize = this.getStepSize();
					for(var i=0; i <= this.numberOfSteps; i++){
						this.steps.push(this.scaleStart + i * stepSize);
					};
					if(this._stepIndex === undefined){
						this._stepIndex = Math.floor(this.steps.length / 2);
					}
				}
			}
			var getCutClosestToRatio = function(total, ratio, minSize){
				var result;
				var distanceFromRatio;
				for(var c = minSize; c <= total - minSize; c++){
					var newDistanceFromRatio = Math.abs(c / total - ratio);
					if(result === undefined || newDistanceFromRatio < distanceFromRatio){
						distanceFromRatio = newDistanceFromRatio;
						result = c;
					}
				}
				return [result, total - result];
			};
			var divideVertically = function(){
				var height = window.innerHeight;
				var cobwebCanvas = document.getElementById("cobweb");
				cobwebCanvas.style.height = height + "px";
				cobwebCanvas.style.width = height + "px";
				var bifurcationDiagramCanvas = document.getElementById("bifurcationDiagram");
				var bifurcationDiagramWidth = window.innerWidth - height - 10;
				bifurcationDiagramCanvas.style.width = bifurcationDiagramWidth + "px";
				bifurcationDiagramCanvas.style.height = height + "px";
			};

			divideVertically();

			var bifurcationDiagram;
			var progress;
			var controls;
			var cobweb;
			var scaleWithValue = new ScaleWithValue(120);
			var valueDiv = document.getElementById("value");
			var cut = getCutClosestToRatio(navigator.hardwareConcurrency, 1 / 6, 1);
			var currentPlayback = undefined;
			var handleChange = function(){
				var newValue = scaleWithValue.value;
				if(newValue !== undefined){
					cobweb.drawWithValue(newValue);
					bifurcationDiagram.setMarkerAtValue(newValue);
					valueDiv.innerText = "r = "+newValue
				}
			};
			var doIt = function(){
				bifurcationDiagram.setStartAndEnd(scaleWithValue.scaleStart, scaleWithValue.scaleEnd);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var setScale = function(start, end){
				scaleWithValue.setScale(start, end);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var advanceStep = function(){
				scaleWithValue.advanceStep();
				handleChange();
			};
			var retreatStep = function(){
				scaleWithValue.retreatStep();
				handleChange();
			};
			var moveScaleRight = function(){
				scaleWithValue.moveScaleRight();
				doIt();
			};
			var moveScaleLeft = function(){
				scaleWithValue.moveScaleLeft();
				doIt();
			};
			var zoomIn = function(){
				scaleWithValue.zoom(0.5);
				doIt();
			};
			var zoomOut = function(){
				scaleWithValue.zoom(2);
				doIt();
			};
			var goToValueClosestToRatio = function(ratio){
				scaleWithValue.goToValueClosestToRatio(ratio);
				handleChange();
			};
			var startPlayback = function(){
				controls.togglePlaying(true);
				currentPlayback = cobweb.startPlayback(scaleWithValue.getStepSize() / 100);
			};
			var stopPlayback = function(){
				currentPlayback.stop();
				currentPlayback = undefined;
				controls.togglePlaying(false);
				cobweb.setSteps(scaleWithValue.steps);
			};

			progress = (function(){
				var container = document.getElementById("cobwebProgress");
				var done = document.getElementById("cobwebProgressDone");
				var setRatio = function(ratio){
					if(ratio === 1){
						container.style.visibility = "hidden";
					}else{
						container.style.visibility = "visible";
						done.style.width = "" + Math.floor(100 * ratio) + "%";
					}
				};
				return {setRatio: setRatio}
			})();

			cobweb = (function(){
				var canvas;
				var width, height;
				var createCanvas = function(){
					var oldCanvas = document.getElementById("cobweb");
					var rect = oldCanvas.getBoundingClientRect();
					var styleWidth = oldCanvas.style.width;
					var styleHeight = oldCanvas.style.height;
					width = rect.width * devicePixelRatio;
					height = Math.ceil(rect.height * devicePixelRatio);
					var parent = oldCanvas.parentElement;
					canvas = document.createElement("canvas");
					canvas.setAttribute("width", width);
					canvas.setAttribute("height", height);
					canvas.setAttribute("id", "cobweb");
					canvas.style.width = styleWidth;
					canvas.style.height = styleHeight;
					parent.insertBefore(canvas, oldCanvas);
					parent.removeChild(oldCanvas);
				};
				//var canvas = document.getElementById("cobweb");
				createCanvas();
				//var rect = canvas.getBoundingClientRect();
				//var width = rect.width * devicePixelRatio, height = Math.ceil(rect.height * devicePixelRatio);
				
				var ctx = canvas.getContext("2d");
				var currentlyDrawnValue;
				var images = [];
				var currentCancellationToken = undefined;
				var processorInitialized = false;
				var cobwebProcessor = new ParallelProcessor(5, createPathToScript("cobweb-processor.js"));

				var drawWithValue = function(r){
					currentlyDrawnValue = r;
					var image = images.find(function(i){return i.value === r});
					if(!image){
						console.warn("image not present!");
						return;
					}
					image.draw(ctx);
				};
				var removeOldImages = function(newSteps){
					var newImages = [];
					for(var i=0;i<images.length;i++){
						var image = images[i];
						if(newSteps.includes(image.value)){
							newImages.push(image);
						}else{
							image.discard();
						}
					}
					images = newImages;
				};
				var reportNumberOfImagesLoaded = function(){
					var number = images.filter(function(i){return i.loaded;}).length;
					progress.setRatio(number / images.length);
				};
				var setSteps = async function(steps){
					var newSteps = steps.filter(function(v){return !images.find(function(i){return i.value === v;});});
					removeOldImages(steps);
					if(newSteps.length === 0){
						return;
					}
					if(!processorInitialized){
						await cobwebProcessor.update(height);
						processorInitialized = true;
					}
					var newImageSet = new CobwebImageSet(cobwebProcessor, newSteps);
					for(var i=0;i<newImageSet.images.length;i++){
						images.push(newImageSet.images[i]);
					}
					newImageSet.addImageLoadedHandler(function(i){
						reportNumberOfImagesLoaded();
						if(currentlyDrawnValue === i.value){
							i.draw(ctx);
						}
					});
					reportNumberOfImagesLoaded();
					newImageSet.load();
				};
				var startPlayback = function(valueStep){
					setSteps([]);
					var latestValue = currentlyDrawnValue;
					var bufferLength = 300;
					var createValues = function(){
						console.log("creating values");
						var result = Array.apply(null, new Array(bufferLength)).map(function(x, i){return latestValue + i * valueStep;});
						latestValue = result[result.length - 1];
						return result;
					};
					var onDisplayValue = function(value){
						bifurcationDiagram.setMarkerAtValue(value);
						valueDiv.innerText = "r = "+value
					};
					var play = async function(buffer, count){
						var nextBuffer = new OtherBuffer();
						console.log("adding progress handler to buffer");
						var progressHandler = function(ratio){
							progress.setRatio(ratio);
							if(ratio > 0.5 && !nextBuffer.loading && !nextBuffer.loaded){
								nextBuffer.startLoading(createValues(), height);
							}
						};
						await buffer.addProgressHandler(progressHandler);
						console.log("added progress handler to buffer");
						if(!buffer.loading && !buffer.loaded){
							console.log("current buffer ("+buffer.id+") is not yet loaded or loading")
							buffer.startLoading(createValues(), height);
						}
						var bufferLoadPromise = buffer.load();
						await bufferLoadPromise;
						console.log("buffer is done loading, remove progress handler");
						await buffer.removeProgressHandler(progressHandler);
						console.log("removed progress handler, start playing");
						createCanvas();
						await buffer.playInTime(canvas, 9000, onDisplayValue);
						console.log("buffer is done playing, discarding");
						await buffer.discard();
						console.log("buffer discarded");
						if(count < 1){
							play(nextBuffer, count + 1);
						}
					};
					
					var stop = function(){
						console.log("stopping playback")
					};
					
					play(new OtherBuffer(), 0);
					return {stop: stop};
				};
				return {
					drawWithValue: drawWithValue,
					setSteps: setSteps,
					startPlayback: startPlayback
				};
			})();

			bifurcationDiagram = (function(){
				var valueMarker = document.getElementById("valueMarker");
				var canvas = document.getElementById("bifurcationDiagram");
				var rect = canvas.getBoundingClientRect();
				valueMarker.style.height = rect.height + "px";
				var width = Math.ceil(rect.width * devicePixelRatio), height = Math.ceil(rect.height * devicePixelRatio);
				var canvasX = rect.x;
				canvas.setAttribute("width", width);
				canvas.setAttribute("height", height);
				var context = canvas.getContext("2d");
				var sliceWidth = 10;
				var currentCancellationToken = undefined;
				var coordsMinX;
				var coordsMaxX;
				var coordsMinY = 0;
				var coordsMaxY = 1;
				var trailing = false;
				var processor = new ParallelProcessor(4, createPathToScript("bifurcation-diagram-processor.js"));

				var drawSlice = async function(x, cancellationToken){
					var buffer = await processor.process({x: x}, cancellationToken);
					var array = new Uint8ClampedArray(buffer);
					var imageData = new ImageData(array, sliceWidth);
					context.putImageData(imageData, x, 0);
				};

				var setMarkerAtValue = function(value){
					var relativeValue = (value - coordsMinX) / (coordsMaxX - coordsMinX);
					valueMarker.style.left = (rect.x + rect.width * relativeValue) + "px";
				};

				var drawAll = async function(){
					if(currentCancellationToken){
						currentCancellationToken.cancel();
					}
					context.clearRect(0, 0, width, height);
					await processor.update(sliceWidth, coordsMinX, coordsMinY, coordsMaxX, coordsMaxY, width, height);
					currentCancellationToken = processor.getCancellationToken();
					var numberOfSlices = Math.ceil(width / sliceWidth);
					for(var i=0;i<numberOfSlices;i++){
						drawSlice(i * sliceWidth, currentCancellationToken);
					}
				};

				var setStartAndEnd = function(start, end){
					coordsMinX = start;
					coordsMaxX = end;
					drawAll();
				};

				canvas.addEventListener("mousedown", function(){
					if(currentPlayback){
						return;
					}
					trailing = true;
				});

				canvas.addEventListener("mouseup", function(){
					if(currentPlayback){
						return;
					}
					trailing = false;
				});

				canvas.addEventListener("mousemove", function(e){
					if(currentPlayback){
						return;
					}
					if(!trailing){
						return;
					}
					var ratio = (e.clientX - rect.x) / rect.width;
					goToValueClosestToRatio(ratio);
				});

				return {
					setMarkerAtValue: setMarkerAtValue,
					setStartAndEnd: setStartAndEnd
				};
			})();

			controls = (function(){
				var startPlayButton = document.getElementById("play");
				var stopPlayButton = document.getElementById("stop");
				startPlayButton.addEventListener("click", function(){
					startPlayback();
				});
				stopPlayButton.addEventListener("click", function(){
					stopPlayback();
				});
				document.getElementById("decrease").addEventListener("click", function(){
					retreatStep();
				});
				document.getElementById("increase").addEventListener("click", function(){
					advanceStep();
				});
				document.getElementById("goleft").addEventListener("click", function(){
					moveScaleLeft();
				});
				document.getElementById("goright").addEventListener("click", function(){
					moveScaleRight();
				});
				document.getElementById("zoomin").addEventListener("click", function(){
					zoomIn();
				});
				document.getElementById("zoomout").addEventListener("click", function(){
					zoomOut();
				});

				var togglePlaying = function(playing){
					stopPlayButton.style.display = playing ? "unset" : "none";
					startPlayButton.style.display = playing ? "none" : "unset";
				};
				return {togglePlaying: togglePlaying};
			})();

			scaleWithValue.setScale(1, 4);
			controls.togglePlaying(false);
			doIt();
		})();
	</script>
</body>
</html>