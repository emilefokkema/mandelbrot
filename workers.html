<html>
	<head>
		<script type="text/javascript" src="parallel-processor.js"></script>
		<style type="text/css">
			body{padding:0px;margin:0px;overflow: hidden;}
			#container{height:100%;}
			#left{display: inline-block;height:100%;}
			#right{display: inline-block;height:100%;}
			#valueMarker{position:absolute;bottom:0px;width:1px;background-color: #f00;}
			#controls{position:absolute;right:20px;bottom:20px;padding:20px;background-color: #fff;border: 1pt solid #000;}
			.control{user-select: none;cursor:pointer;display: inline-block;margin:3px;background-color: #aaa;}
			#cobwebProgress{position:absolute;left:10px;top:10px;}
			.progress{width:100px;height:10px;border:1pt solid #000;}
			.progress .done{width:0%;height:100%;background-color: #000;}
			#value{font-family: monospace;font-size: 15px;}
		</style>
	</head>
<body>

	<div id="container">
		<div id="left">
			<canvas id="cobweb"></canvas>
			<div id="cobwebProgress" class="progress">
				<div class="done" id="cobwebProgressDone"></div>
			</div>
		</div>
		<div id="right">
			<canvas id="bifurcationDiagram"></canvas>
			<div id="valueMarker"></div>
			<div id="controls">
				<div id="decrease" class="control">decrease</div>
				<div id="increase" class="control">increase</div>
				<div id="goleft" class="control">left</div>
				<div id="goright" class="control">right</div>
				<div id="zoomin" class="control">zoom in</div>
				<div id="zoomout" class="control">zoom out</div>
				<div id="play" class="control">play</div>
				<div id="stop" class="control">stop</div>
				<div id="value">r = 0.5</div>
			</div>
		</div>
	</div>
	
	
	<script>
		(function(){
			class CobwebImage{
				constructor(processor, value, height){
					this.value = value;
					this.cancallationToken = undefined;
					this.processor = processor;
					this.height = height;
					this.image = undefined;
					this.objectUrl = undefined;
				}
				get loaded(){return !!this.image;}
				async load(){
					var self = this;
					if(this.cancellationToken){
						return;
					}
					this.cancellationToken = this.processor.getCancellationToken();
					var blob = await this.processor.process({r: this.value}, this.cancellationToken);
					var image = new Image();
					this.objectUrl = URL.createObjectURL(blob);
					await new Promise(function(resolve, reject){
						image.addEventListener("load", function(){
							self.image = image;
							resolve();
						});
						image.src = self.objectUrl;
					});
				}
				discard(){
					if(this.cancellationToken){
						this.cancellationToken.cancel();
					}
					if(this.objectUrl !== undefined){
						URL.revokeObjectURL(this.objectUrl);
					}
					this.image = undefined;
				}
			}
			class CobwebImageBuffer{
				constructor(processor, startValue, valueStep, length, height){
					this.processor = processor;
					this.startValue = startValue;
					this.valueStep = valueStep;
					this.length = length;
					this.height = height;
					this.images = [];
					this.onProgressHandler = undefined;
					this._loadingPromise = undefined;
					this.createImages();
				}
				createImages(){
					var value = this.startValue;
					for(var i=0;i<this.length;i++){
						this.images.push(new CobwebImage(this.processor, value, this.height));
						value += this.valueStep;
					}
				}
				get lastValue(){
					return this.images[this.images.length - 1].value;
				}
				discard(){
					for(var i=0;i<this.images.length;i++){
						this.images[i].discard();
					}
				}
				async loadImage(image){
					await image.load();
					this.reportProgress();
				}
				async loadImages(){
					var start = +new Date();
					var promises = [];
					for(var i=0;i<this.images.length;i++){
						promises.push(this.loadImage(this.images[i]));
					}
					await Promise.all(promises);
					console.log("loaded buffer images in "+(+new Date() - start)+" ms");
				}
				reportProgress(){
					if(this.onProgressHandler){
						var progress = this.images.filter(function(i){return i.loaded;}).length / this.images.length;
						this.onProgressHandler(progress);
					}
				}
				async play(context, interval, onDisplayValue){
					console.log("playing buffer");
					for(var i=0;i<this.images.length;i++){
						context.drawImage(this.images[i].image, 0, 0);
						onDisplayValue && onDisplayValue(this.images[i].value);
						await new Promise(function(res){setTimeout(res, interval);});
					}
				}
				reportProgressWhileLoading(onProgressHandler){
					this.onProgressHandler = onProgressHandler;
					this.reportProgress();
					if(!this._loadingPromise){
						this.load();
					}
					return this._loadingPromise;
				}
				load(){
					this._loadingPromise = this.loadImages();
				}
			}
			class ScaleWithValue{
				constructor(numberOfSteps){
					this._stepIndex = undefined;
					this.scaleStart = undefined;
					this.scaleEnd = undefined;
					this.numberOfSteps = numberOfSteps;
					this.steps = [];
				}
				get value(){
					return this.steps ? this.steps[this._stepIndex] : undefined;
				}
				setScale(start, end){
					this.scaleStart = start;
					this.scaleEnd = end;
					this.createSteps();
				}
				advanceStep(){
					this._stepIndex = Math.min(this.steps.length - 1, this._stepIndex + 1);
				}
				retreatStep(){
					this._stepIndex = Math.max(0, this._stepIndex - 1);
				}
				zoom(scale){
					var newSteps = this.steps.slice();
					var currentValue = this.steps[this._stepIndex];
					for(var i=0;i<newSteps.length;i++){
						if(i !== this._stepIndex){
							newSteps[i] = currentValue + (newSteps[i] - currentValue) * scale;
						}
					}
					this.steps = newSteps;
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.steps[this.steps.length - 1];
				}
				goToValueClosestToRatio(ratio){
					this._stepIndex = Math.floor((this.steps.length - 1) * ratio);
				}
				moveScaleRight(){
					var stepSize = this.getStepSize();
					this.steps.splice(0, 1);
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.scaleEnd + stepSize;
					this.steps.push(this.scaleEnd);
				}
				moveScaleLeft(){
					var stepSize = this.getStepSize();
					this.steps.splice(this.steps.length - 1, 1);
					this.scaleEnd = this.steps[this.steps.length - 1];
					this.scaleStart -= stepSize;
					this.steps.unshift(this.scaleStart);
				}
				getStepSize(){
					return (this.scaleEnd - this.scaleStart) / (this.numberOfSteps);
				}
				createSteps(){
					this.steps = [];
					var stepSize = this.getStepSize();
					for(var i=0; i <= this.numberOfSteps; i++){
						this.steps.push(this.scaleStart + i * stepSize);
					};
					if(this._stepIndex === undefined){
						this._stepIndex = Math.floor(this.steps.length / 2);
					}
				}
			}
			var getCutClosestToRatio = function(total, ratio, minSize){
				var result;
				var distanceFromRatio;
				for(var c = minSize; c <= total - minSize; c++){
					var newDistanceFromRatio = Math.abs(c / total - ratio);
					if(result === undefined || newDistanceFromRatio < distanceFromRatio){
						distanceFromRatio = newDistanceFromRatio;
						result = c;
					}
				}
				return [result, total - result];
			};
			var divideVertically = function(){
				var height = window.innerHeight;
				var cobwebCanvas = document.getElementById("cobweb");
				cobwebCanvas.style.height = height + "px";
				cobwebCanvas.style.width = height + "px";
				var bifurcationDiagramCanvas = document.getElementById("bifurcationDiagram");
				var bifurcationDiagramWidth = window.innerWidth - height - 10;
				bifurcationDiagramCanvas.style.width = bifurcationDiagramWidth + "px";
				bifurcationDiagramCanvas.style.height = height + "px";
			};

			divideVertically();

			var bifurcationDiagram;
			var progress;
			var controls;
			var cobweb;
			var scaleWithValue = new ScaleWithValue(120);
			var valueDiv = document.getElementById("value");
			var cut = getCutClosestToRatio(navigator.hardwareConcurrency, 1 / 6, 1);
			var currentPlayback = undefined;
			var handleChange = function(){
				var newValue = scaleWithValue.value;
				if(newValue !== undefined){
					cobweb.drawWithValue(newValue);
					bifurcationDiagram.setMarkerAtValue(newValue);
					valueDiv.innerText = "r = "+newValue
				}
			};
			var doIt = function(){
				bifurcationDiagram.setStartAndEnd(scaleWithValue.scaleStart, scaleWithValue.scaleEnd);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var setScale = function(start, end){
				scaleWithValue.setScale(start, end);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var advanceStep = function(){
				scaleWithValue.advanceStep();
				handleChange();
			};
			var retreatStep = function(){
				scaleWithValue.retreatStep();
				handleChange();
			};
			var moveScaleRight = function(){
				scaleWithValue.moveScaleRight();
				doIt();
			};
			var moveScaleLeft = function(){
				scaleWithValue.moveScaleLeft();
				doIt();
			};
			var zoomIn = function(){
				scaleWithValue.zoom(0.5);
				doIt();
			};
			var zoomOut = function(){
				scaleWithValue.zoom(2);
				doIt();
			};
			var goToValueClosestToRatio = function(ratio){
				scaleWithValue.goToValueClosestToRatio(ratio);
				handleChange();
			};
			var startPlayback = function(){
				controls.togglePlaying(true);
				currentPlayback = cobweb.startPlayback(scaleWithValue.getStepSize() / 100);
			};
			var stopPlayback = function(){
				currentPlayback.stop();
				currentPlayback = undefined;
				controls.togglePlaying(false);
				cobweb.setSteps(scaleWithValue.steps);
			};

			progress = (function(){
				var container = document.getElementById("cobwebProgress");
				var done = document.getElementById("cobwebProgressDone");
				var setRatio = function(ratio){
					if(ratio === 1){
						container.style.visibility = "hidden";
					}else{
						container.style.visibility = "visible";
						done.style.width = "" + Math.floor(100 * ratio) + "%";
					}
				};
				return {setRatio: setRatio}
			})();

			cobweb = (function(){
				var canvas = document.getElementById("cobweb");
				var ctx = canvas.getContext("2d");
				var rect = canvas.getBoundingClientRect();
				var width = rect.width * devicePixelRatio, height = Math.ceil(rect.height * devicePixelRatio);
				canvas.setAttribute("width", width);
				canvas.setAttribute("height", height);
				var currentlyDrawnValue;
				var images = [];
				var currentCancellationToken = undefined;
				var processorInitialized = false;
				var cobwebProcessor = new ParallelProcessor(cut[1], "("+(function(){
					var height;
					process = function(req){
						var r = req.r;
						var canvas = new OffscreenCanvas(height, height);
						var ctx = canvas.getContext("2d");
						ctx.fillStyle = "#fff";
						ctx.fillRect(0, 0, height, height);
						ctx.beginPath();
						ctx.moveTo(0, height);
						ctx.quadraticCurveTo(height / 2, height * (1 - r / 2), height, height);
						ctx.moveTo(0, height);
						ctx.lineTo(height, 0);
						ctx.stroke();

						var value = 0.5;
						//var hue = 0;
						var counter = 0;
						ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
						ctx.lineWidth = 0.1;
						while(counter < 40000){
							//ctx.strokeStyle = "hsla("+hue+",100%,50%,0.2)";
							ctx.beginPath();
							ctx.moveTo(value * height, (1 - value) * height);
							var newValue = r * value * (1 - value);
							ctx.lineTo(value * height, (1 - newValue) * height);
							ctx.lineTo(newValue * height, (1 - newValue) * height);
							ctx.stroke();
							value = newValue;
							//hue += 0.03;
							counter++;
						}
						//var imageData = ctx.getImageData(0, 0, height, height);
						//return imageData.data.buffer;
						return canvas.convertToBlob({type: "image/jpeg", quality: 1});
					};
					update = function(_height){
						height = _height;
					};
				}).toString()+")()", false);
				var displayImage = function(image){
					// if(!image.bitmap){
					// 	console.warn("image bitmap not present!");
					// 	return;
					// }
					// ctx.clearRect(0, 0, height, height);
					// ctx.drawImage(image.bitmap, 0, 0, height, height);
					if(!image.image){
						console.warn("image not present!");
						return;
					}
					ctx.drawImage(image.image, 0, 0);
				};
				var drawWithValue = function(r){
					currentlyDrawnValue = r;
					var image = images.find(function(i){return i.value === r});
					if(!image){
						console.warn("image not present!");
						return;
					}
					displayImage(image);
				};
				var removeOldImages = function(newSteps){
					var newImages = [];
					for(var i=0;i<images.length;i++){
						var image = images[i];
						if(newSteps.includes(image.value)){
							newImages.push(image);
						}else{
							image.discard();
						}
					}
					images = newImages;
				};
				var reportNumberOfImagesLoaded = function(){
					var number = images.filter(function(i){return i.loaded;}).length;
					progress.setRatio(number / images.length);
				};
				var createNewImage = async function(value){
					var newImage = new CobwebImage(cobwebProcessor, value, height);
					images.push(newImage);
					await newImage.load();
					reportNumberOfImagesLoaded();
					if(currentlyDrawnValue === value){
						displayImage(newImage);
					}
				};
				var setSteps = async function(steps){
					var newSteps = steps.filter(function(v){return !images.find(function(i){return i.value === v;});});
					removeOldImages(steps);
					if(newSteps.length === 0){
						return;
					}
					if(!processorInitialized){
						await cobwebProcessor.update(height);
						processorInitialized = true;
					}
					for(var i=0; i < newSteps.length; i++){
						createNewImage(newSteps[i]);
					}
					reportNumberOfImagesLoaded();
				};
				var startPlayback = function(valueStep){
					console.log("starting playback with step " + valueStep)
					setSteps([]);
					//var currentBuffer = new CobwebImageBuffer(cobwebProcessor, currentlyDrawnValue, valueStep, 10, height);

					var loadBufferAndReportProgress = function(buffer){
						return buffer.reportProgressWhileLoading(function(ratio){progress.setRatio(ratio);});
					};
					var createBuffer = function(startValue){
						return new CobwebImageBuffer(cobwebProcessor, startValue, valueStep, 200, height);
					};
					var onDisplayValue = function(value){
						bifurcationDiagram.setMarkerAtValue(value);
						valueDiv.innerText = "r = "+value
					};
					var play = async function(buffer){
						var nextBuffer = createBuffer(buffer.lastValue + valueStep);//new CobwebImageBuffer(cobwebProcessor, buffer.lastValue + valueStep, valueStep, 10, height);
						
						var bufferLoadPromise = loadBufferAndReportProgress(buffer);
						nextBuffer.load();
						await bufferLoadPromise;
						await buffer.play(ctx, 70, onDisplayValue);
						buffer.discard();
						play(nextBuffer);
					};
					
					var stop = function(){
						console.log("stopping playback")
					};
					//play(new CobwebImageBuffer(cobwebProcessor, currentlyDrawnValue, valueStep, 10, height));
					play(createBuffer(currentlyDrawnValue));
					return {stop: stop};
				};
				return {
					drawWithValue: drawWithValue,
					setSteps: setSteps,
					startPlayback: startPlayback
				};
			})();

			bifurcationDiagram = (function(){
				var valueMarker = document.getElementById("valueMarker");
				var canvas = document.getElementById("bifurcationDiagram");
				var rect = canvas.getBoundingClientRect();
				valueMarker.style.height = rect.height + "px";
				var width = Math.ceil(rect.width * devicePixelRatio), height = Math.ceil(rect.height * devicePixelRatio);
				var canvasX = rect.x;
				canvas.setAttribute("width", width);
				canvas.setAttribute("height", height);
				var context = canvas.getContext("2d");
				var sliceWidth = 10;
				var currentCancellationToken = undefined;
				var coordsMinX;
				var coordsMaxX;
				var coordsMinY = 0;
				var coordsMaxY = 1;
				var trailing = false;
				var processor = new ParallelProcessor(cut[0], "(" + (function(){
					var sliceWidth, coordsMinX, coordsMinY, coordsMaxX, coordsMaxY, width, height;
					var pointWidth;
					var getCoordsX = function(x){
						return coordsMinX + (coordsMaxX - coordsMinX) * x / width;
					};
					var getRealY = function(y){
						return Math.floor(height * (coordsMaxY - y) / (coordsMaxY - coordsMinY));
					};
					var getArrayIndexForPoint = function(x, y){
						return 4 * sliceWidth * y + 4 * x;
					};
					var colorPoint = function(x, y, array){
						if(x >= 0 && x < sliceWidth && y >= 0 && y < height){
							var index = getArrayIndexForPoint(x, y);
							array[index + 3] += pointWidth;
						}
					};
					var displayValue = function(value, x, array){
						var realY = getRealY(value);
						colorPoint(x, realY, array);
					};
					var drawPointsForX = function(sliceStart, x, array){
						var coordsX = getCoordsX(sliceStart + x);
						var value = 0.1;
						var counter = 0;
						while(counter < 40000){
							if(counter > 5000){
								displayValue(value, x, array);
							}
							value = coordsX * value * (1 - value);
							counter++;
						}
					};
					process = function(req){
						var array = new Uint8ClampedArray(4 * sliceWidth * height);
						for(var x = 0; x < sliceWidth; x++){
							drawPointsForX(req.x, x, array);
						}
						return array.buffer;
					};
					update = function(_sliceWidth, _coordsMinX, _coordsMinY, _coordsMaxX, _coordsMaxY, _width, _height){
						sliceWidth = _sliceWidth;
						coordsMinX = _coordsMinX;
						coordsMinY = _coordsMinY;
						coordsMaxX = _coordsMaxX;
						coordsMaxY = _coordsMaxY;
						width = _width;
						height = _height;
						pointWidth = 5;
					};		
				}).toString() + ")()");

				var drawSlice = async function(x, cancellationToken){
					var buffer = await processor.process({x: x}, cancellationToken);
					var array = new Uint8ClampedArray(buffer);
					var imageData = new ImageData(array, sliceWidth);
					context.putImageData(imageData, x, 0);
				};

				var setMarkerAtValue = function(value){
					var relativeValue = (value - coordsMinX) / (coordsMaxX - coordsMinX);
					valueMarker.style.left = (rect.x + rect.width * relativeValue) + "px";
				};

				var drawAll = async function(){
					if(currentCancellationToken){
						currentCancellationToken.cancel();
					}
					context.clearRect(0, 0, width, height);
					await processor.update(sliceWidth, coordsMinX, coordsMinY, coordsMaxX, coordsMaxY, width, height);
					currentCancellationToken = processor.getCancellationToken();
					var numberOfSlices = Math.ceil(width / sliceWidth);
					for(var i=0;i<numberOfSlices;i++){
						drawSlice(i * sliceWidth, currentCancellationToken);
					}
				};

				var setStartAndEnd = function(start, end){
					coordsMinX = start;
					coordsMaxX = end;
					drawAll();
				};

				canvas.addEventListener("mousedown", function(){
					if(currentPlayback){
						return;
					}
					trailing = true;
				});

				canvas.addEventListener("mouseup", function(){
					if(currentPlayback){
						return;
					}
					trailing = false;
				});

				canvas.addEventListener("mousemove", function(e){
					if(currentPlayback){
						return;
					}
					if(!trailing){
						return;
					}
					var ratio = (e.clientX - rect.x) / rect.width;
					goToValueClosestToRatio(ratio);
				});

				return {
					setMarkerAtValue: setMarkerAtValue,
					setStartAndEnd: setStartAndEnd
				};
			})();

			controls = (function(){
				var startPlayButton = document.getElementById("play");
				var stopPlayButton = document.getElementById("stop");
				startPlayButton.addEventListener("click", function(){
					startPlayback();
				});
				stopPlayButton.addEventListener("click", function(){
					stopPlayback();
				});
				document.getElementById("decrease").addEventListener("click", function(){
					retreatStep();
				});
				document.getElementById("increase").addEventListener("click", function(){
					advanceStep();
				});
				document.getElementById("goleft").addEventListener("click", function(){
					moveScaleLeft();
				});
				document.getElementById("goright").addEventListener("click", function(){
					moveScaleRight();
				});
				document.getElementById("zoomin").addEventListener("click", function(){
					zoomIn();
				});
				document.getElementById("zoomout").addEventListener("click", function(){
					zoomOut();
				});

				var togglePlaying = function(playing){
					stopPlayButton.style.display = playing ? "unset" : "none";
					startPlayButton.style.display = playing ? "none" : "unset";
				};
				return {togglePlaying: togglePlaying};
			})();

			scaleWithValue.setScale(1, 4);
			controls.togglePlaying(false);
			doIt();
		})();
	</script>
</body>
</html>