<html>
	<head>
		<script type="text/javascript" src="parallel-processor.js"></script>
		<style type="text/css">
			body{padding:0px;margin:0px;overflow: hidden;}
			#container{height:100%;}
			#left{display: inline-block;height:100%;}
			#right{display: inline-block;height:100%;}
			#valueMarker{position:absolute;bottom:0px;width:1px;background-color: #f00;}
			#controls{position:absolute;right:20px;bottom:20px;padding:20px;background-color: #fff;border: 1pt solid #000;}
			.control{user-select: none;cursor:pointer;display: inline-block;}
			#cobwebProgress{position:absolute;left:10px;top:10px;}
			.progress{width:100px;height:10px;border:1pt solid #000;}
			.progress .done{width:0%;height:100%;background-color: #000;}
			#value{font-family: monospace;font-size: 15px;}
		</style>
	</head>
<body>

	<div id="container">
		<div id="left">
			<canvas id="cobweb"></canvas>
			<div id="cobwebProgress" class="progress">
				<div class="done" id="cobwebProgressDone"></div>
			</div>
		</div>
		<div id="right">
			<canvas id="bifurcationDiagram"></canvas>
			<div id="valueMarker"></div>
			<div id="controls">
				<div id="decrease" class="control">decrease</div>
				<div id="increase" class="control">increase</div>
				<div id="goleft" class="control">left</div>
				<div id="goright" class="control">right</div>
				<div id="zoomin" class="control">zoom in</div>
				<div id="zoomout" class="control">zoom out</div>
				<div id="value">r = 0.5</div>
			</div>
		</div>
	</div>
	
	
	<script>
		(function(){
			class CobwebImage{
				constructor(processor, value, height){
					this.value = value;
					this.cancallationToken = undefined;
					this.processor = processor;
					this.height = height;
					this.image = undefined;
				}
				get loaded(){return !!this.image;}
				async load(){
					var self = this;
					if(this.cancellationToken){
						return;
					}
					this.cancellationToken = this.processor.getCancellationToken();
					var blob = await this.processor.process({r: this.value}, this.cancellationToken);
					var image = new Image();
					await new Promise(function(resolve, reject){
						image.addEventListener("load", function(){
							self.image = image;
							resolve();
						});
						image.src = URL.createObjectURL(blob);
					});
				}
				cancelLoad(){
					if(this.cancellationToken){
						this.cancellationToken.cancel();
					}
				}
			}
			class ScaleWithValue{
				constructor(numberOfSteps){
					this._stepIndex = undefined;
					this.scaleStart = undefined;
					this.scaleEnd = undefined;
					this.numberOfSteps = numberOfSteps;
					this.steps = [];
				}
				get value(){
					return this.steps ? this.steps[this._stepIndex] : undefined;
				}
				setScale(start, end){
					console.log("setting scale");
					this.scaleStart = start;
					this.scaleEnd = end;
					this.createSteps();
				}
				advanceStep(){
					this._stepIndex = Math.min(this.steps.length - 1, this._stepIndex + 1);
				}
				retreatStep(){
					this._stepIndex = Math.max(0, this._stepIndex - 1);
				}
				zoom(scale){
					var newSteps = this.steps.slice();
					var currentValue = this.steps[this._stepIndex];
					for(var i=0;i<newSteps.length;i++){
						if(i !== this._stepIndex){
							newSteps[i] = currentValue + (newSteps[i] - currentValue) * scale;
						}
					}
					this.steps = newSteps;
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.steps[this.steps.length - 1];
				}
				goToValueClosestToRatio(ratio){
					this._stepIndex = Math.floor((this.steps.length - 1) * ratio);
				}
				moveScaleRight(){
					var stepSize = this.getStepSize();
					this.steps.splice(0, 1);
					this.scaleStart = this.steps[0];
					this.scaleEnd = this.scaleEnd + stepSize;
					this.steps.push(this.scaleEnd);
				}
				moveScaleLeft(){
					var stepSize = this.getStepSize();
					this.steps.splice(this.steps.length - 1, 1);
					this.scaleEnd = this.steps[this.steps.length - 1];
					this.scaleStart -= stepSize;
					this.steps.unshift(this.scaleStart);
				}
				getStepSize(){
					return (this.scaleEnd - this.scaleStart) / (this.numberOfSteps);
				}
				createSteps(){
					this.steps = [];
					var stepSize = this.getStepSize();
					for(var i=0; i <= this.numberOfSteps; i++){
						this.steps.push(this.scaleStart + i * stepSize);
					};
					if(this._stepIndex === undefined){
						this._stepIndex = Math.floor(this.steps.length / 2);
					}
				}
			}

			var divideVertically = function(){
				var height = window.innerHeight;
				var cobwebCanvas = document.getElementById("cobweb");
				cobwebCanvas.style.height = height + "px";
				cobwebCanvas.style.width = height + "px";
				var bifurcationDiagramCanvas = document.getElementById("bifurcationDiagram");
				var bifurcationDiagramWidth = window.innerWidth - height - 10;
				bifurcationDiagramCanvas.style.width = bifurcationDiagramWidth + "px";
				bifurcationDiagramCanvas.style.height = height + "px";
			};

			divideVertically();

			var bifurcationDiagram;
			var progress;
			var controls;
			var cobweb;
			var scaleWithValue = new ScaleWithValue(120);
			var valueDiv = document.getElementById("value");
			var handleChange = function(){
				var newValue = scaleWithValue.value;
				if(newValue !== undefined){
					cobweb.drawWithValue(newValue);
					bifurcationDiagram.setMarkerAtValue(newValue);
					valueDiv.innerText = "r = "+newValue
				}
			};
			var doIt = function(){
				bifurcationDiagram.setStartAndEnd(scaleWithValue.scaleStart, scaleWithValue.scaleEnd);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var setScale = function(start, end){
				scaleWithValue.setScale(start, end);
				cobweb.setSteps(scaleWithValue.steps);
				handleChange();
			};
			var advanceStep = function(){
				scaleWithValue.advanceStep();
				handleChange();
			};
			var retreatStep = function(){
				scaleWithValue.retreatStep();
				handleChange();
			};
			var moveScaleRight = function(){
				scaleWithValue.moveScaleRight();
				doIt();
			};
			var moveScaleLeft = function(){
				scaleWithValue.moveScaleLeft();
				doIt();
			};
			var zoomIn = function(){
				scaleWithValue.zoom(0.5);
				doIt();
			};
			var zoomOut = function(){
				scaleWithValue.zoom(2);
				doIt();
			};
			var goToValueClosestToRatio = function(ratio){
				scaleWithValue.goToValueClosestToRatio(ratio);
				handleChange();
			};

			progress = (function(){
				var container = document.getElementById("cobwebProgress");
				var done = document.getElementById("cobwebProgressDone");
				var setRatio = function(ratio){
					if(ratio === 1){
						container.style.visibility = "hidden";
					}else{
						container.style.visibility = "visible";
						done.style.width = "" + Math.floor(100 * ratio) + "%";
					}
				};
				return {setRatio: setRatio}
			})();

			cobweb = (function(){
				var canvas = document.getElementById("cobweb");
				var ctx = canvas.getContext("2d");
				var rect = canvas.getBoundingClientRect();
				var width = rect.width * devicePixelRatio, height = Math.ceil(rect.height * devicePixelRatio);
				canvas.setAttribute("width", width);
				canvas.setAttribute("height", height);
				var currentlyDrawnValue;
				var images = [];
				var currentCancellationToken = undefined;
				var processorInitialized = false;
				var cobwebProcessor = new ParallelProcessor(5, "("+(function(){
					var height;
					process = function(req){
						var r = req.r;
						var canvas = new OffscreenCanvas(height, height);
						var ctx = canvas.getContext("2d");
						ctx.fillStyle = "#fff";
						ctx.fillRect(0, 0, height, height);
						ctx.beginPath();
						ctx.moveTo(0, height);
						ctx.quadraticCurveTo(height / 2, height * (1 - r / 2), height, height);
						ctx.moveTo(0, height);
						ctx.lineTo(height, 0);
						ctx.stroke();

						var value = 0.5;
						//var hue = 0;
						var counter = 0;
						ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
						ctx.lineWidth = 0.1;
						while(counter < 40000){
							//ctx.strokeStyle = "hsla("+hue+",100%,50%,0.2)";
							ctx.beginPath();
							ctx.moveTo(value * height, (1 - value) * height);
							var newValue = r * value * (1 - value);
							ctx.lineTo(value * height, (1 - newValue) * height);
							ctx.lineTo(newValue * height, (1 - newValue) * height);
							ctx.stroke();
							value = newValue;
							//hue += 0.03;
							counter++;
						}
						//var imageData = ctx.getImageData(0, 0, height, height);
						//return imageData.data.buffer;
						return canvas.convertToBlob({type: "image/jpeg"});
					};
					update = function(_height){
						height = _height;
					};
				}).toString()+")()", false);
				var displayImage = function(image){
					// if(!image.bitmap){
					// 	console.warn("image bitmap not present!");
					// 	return;
					// }
					// ctx.clearRect(0, 0, height, height);
					// ctx.drawImage(image.bitmap, 0, 0, height, height);
					if(!image.image){
						console.warn("image not present!");
						return;
					}
					ctx.drawImage(image.image, 0, 0);
				};
				var drawWithValue = function(r){
					currentlyDrawnValue = r;
					var image = images.find(function(i){return i.value === r});
					if(!image){
						console.warn("image not present!");
						return;
					}
					displayImage(image);
				};
				var removeOldImages = function(newSteps){
					var newImages = [];
					for(var i=0;i<images.length;i++){
						var image = images[i];
						if(newSteps.includes(image.value)){
							newImages.push(image);
						}else{
							image.cancelLoad();
						}
					}
					images = newImages;
				};
				var reportNumberOfImagesLoaded = function(){
					var number = images.filter(function(i){return i.loaded;}).length;
					progress.setRatio(number / images.length);
				};
				var createNewImage = async function(value){
					var newImage = new CobwebImage(cobwebProcessor, value, height);
					images.push(newImage);
					await newImage.load();
					reportNumberOfImagesLoaded();
					if(currentlyDrawnValue === value){
						displayImage(newImage);
					}
				};
				var setSteps = async function(steps){
					var newSteps = steps.filter(function(v){return !images.find(function(i){return i.value === v;});});
					removeOldImages(steps);
					if(newSteps.length === 0){
						return;
					}
					if(!processorInitialized){
						await cobwebProcessor.update(height);
						processorInitialized = true;
					}
					for(var i=0; i < newSteps.length; i++){
						createNewImage(newSteps[i]);
					}
					reportNumberOfImagesLoaded();
				};
				return {
					drawWithValue: drawWithValue,
					setSteps: setSteps
				};
			})();

			bifurcationDiagram = (function(){
				var valueMarker = document.getElementById("valueMarker");
				var canvas = document.getElementById("bifurcationDiagram");
				var rect = canvas.getBoundingClientRect();
				valueMarker.style.height = rect.height + "px";
				var width = Math.ceil(rect.width * devicePixelRatio), height = Math.ceil(rect.height * devicePixelRatio);
				var canvasX = rect.x;
				canvas.setAttribute("width", width);
				canvas.setAttribute("height", height);
				var context = canvas.getContext("2d");
				var sliceWidth = 10;
				var currentCancellationToken = undefined;
				var coordsMinX;
				var coordsMaxX;
				var coordsMinY = 0;
				var coordsMaxY = 1;
				var trailing = false;
				var processor = new ParallelProcessor(5, "(" + (function(){
					var sliceWidth, coordsMinX, coordsMinY, coordsMaxX, coordsMaxY, width, height;
					var pointWidth;
					var getCoordsX = function(x){
						return coordsMinX + (coordsMaxX - coordsMinX) * x / width;
					};
					var getRealY = function(y){
						return Math.floor(height * (coordsMaxY - y) / (coordsMaxY - coordsMinY));
					};
					var getArrayIndexForPoint = function(x, y){
						return 4 * sliceWidth * y + 4 * x;
					};
					var colorPoint = function(x, y, array){
						if(x >= 0 && x < sliceWidth && y >= 0 && y < height){
							var index = getArrayIndexForPoint(x, y);
							array[index + 3] += pointWidth;
						}
					};
					var displayValue = function(value, x, array){
						var realY = getRealY(value);
						colorPoint(x, realY, array);
					};
					var drawPointsForX = function(sliceStart, x, array){
						var coordsX = getCoordsX(sliceStart + x);
						var value = 0.1;
						var counter = 0;
						while(counter < 40000){
							if(counter > 5000){
								displayValue(value, x, array);
							}
							value = coordsX * value * (1 - value);
							counter++;
						}
					};
					process = function(req){
						var array = new Uint8ClampedArray(4 * sliceWidth * height);
						for(var x = 0; x < sliceWidth; x++){
							drawPointsForX(req.x, x, array);
						}
						return array.buffer;
					};
					update = function(_sliceWidth, _coordsMinX, _coordsMinY, _coordsMaxX, _coordsMaxY, _width, _height){
						sliceWidth = _sliceWidth;
						coordsMinX = _coordsMinX;
						coordsMinY = _coordsMinY;
						coordsMaxX = _coordsMaxX;
						coordsMaxY = _coordsMaxY;
						width = _width;
						height = _height;
						pointWidth = 5;
					};		
				}).toString() + ")()");

				var drawSlice = async function(x, cancellationToken){
					var buffer = await processor.process({x: x}, cancellationToken);
					var array = new Uint8ClampedArray(buffer);
					var imageData = new ImageData(array, sliceWidth);
					context.putImageData(imageData, x, 0);
				};

				var setMarkerAtValue = function(value){
					var relativeValue = (value - coordsMinX) / (coordsMaxX - coordsMinX);
					valueMarker.style.left = (rect.x + rect.width * relativeValue) + "px";
				};

				var drawAll = async function(){
					if(currentCancellationToken){
						currentCancellationToken.cancel();
					}
					context.clearRect(0, 0, width, height);
					await processor.update(sliceWidth, coordsMinX, coordsMinY, coordsMaxX, coordsMaxY, width, height);
					currentCancellationToken = processor.getCancellationToken();
					var numberOfSlices = Math.ceil(width / sliceWidth);
					for(var i=0;i<numberOfSlices;i++){
						drawSlice(i * sliceWidth, currentCancellationToken);
					}
				};

				var setStartAndEnd = function(start, end){
					coordsMinX = start;
					coordsMaxX = end;
					drawAll();
				};

				canvas.addEventListener("mousedown", function(){
					trailing = true;
				});

				canvas.addEventListener("mouseup", function(){
					trailing = false;
				});

				canvas.addEventListener("mousemove", function(e){
					if(!trailing){
						return;
					}
					var ratio = (e.clientX - rect.x) / rect.width;
					goToValueClosestToRatio(ratio);
				});

				return {
					setMarkerAtValue: setMarkerAtValue,
					setStartAndEnd: setStartAndEnd
				};
			})();

			controls = (function(){
				document.getElementById("decrease").addEventListener("click", function(){
					retreatStep();
				});
				document.getElementById("increase").addEventListener("click", function(){
					advanceStep();
				});
				document.getElementById("goleft").addEventListener("click", function(){
					moveScaleLeft();
				});
				document.getElementById("goright").addEventListener("click", function(){
					moveScaleRight();
				});
				document.getElementById("zoomin").addEventListener("click", function(){
					zoomIn();
				});
				document.getElementById("zoomout").addEventListener("click", function(){
					zoomOut();
				});
			})();

			scaleWithValue.setScale(1, 4);
			doIt();
		})();
	</script>
</body>
</html>